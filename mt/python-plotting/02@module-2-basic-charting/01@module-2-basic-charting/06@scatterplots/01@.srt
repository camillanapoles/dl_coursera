1
00:00:09,019 --> 00:00:11,958
In the previous lecture,
I introduced the plot function,

2
00:00:11,958 --> 00:00:15,800
which generates a series of lines which
get rendered against an axis object.

3
00:00:16,840 --> 00:00:21,334
Matplotlib actually has a number of useful
plotting methods in the scripting layer

4
00:00:21,334 --> 00:00:23,916
which correspond to
different kinds of plots.

5
00:00:23,916 --> 00:00:25,840
We are not going to go
through all of them here but

6
00:00:25,840 --> 00:00:28,320
we'll touch on a few of the major ones.

7
00:00:28,320 --> 00:00:31,976
Regardless, there are a few things
to keep in mind which we learned in

8
00:00:31,976 --> 00:00:33,246
the previous lecture.

9
00:00:33,246 --> 00:00:37,926
One, pyplot is going to retrieve the
current figure with the function gcf and

10
00:00:37,926 --> 00:00:40,885
then get the current axis
with the function gca.

11
00:00:42,015 --> 00:00:45,290
Pyplot is keeping track of
the axis objects for you.

12
00:00:45,290 --> 00:00:48,410
But don't forget that they're there and
we can get them when we want to get them.

13
00:00:49,590 --> 00:00:54,570
Two, also pyplot just mirrors
the API of the axis objects.

14
00:00:54,570 --> 00:00:58,180
So you can call the plot function
against the pyplot module.

15
00:00:58,180 --> 00:01:02,090
But this is calling the axis plot
functions underneath, so be aware.

16
00:01:03,610 --> 00:01:07,750
And three, finally, remember that
the function declaration from most

17
00:01:07,750 --> 00:01:12,410
of the functions in matplotlib end
with an open set of keyword arguments.

18
00:01:12,410 --> 00:01:15,340
There are a lot of different properties
you can control through these

19
00:01:15,340 --> 00:01:16,600
keyword arguments.

20
00:01:16,600 --> 00:01:19,840
And I'll start peppering in some of
them this week to demostrate that

21
00:01:19,840 --> 00:01:23,180
the matplotlib documentation
isreally key in

22
00:01:23,180 --> 00:01:25,640
gaining a full understanding
of the options available.

23
00:01:27,490 --> 00:01:31,070
With that in mind let's move on
to talk first about scatterplots.

24
00:01:32,270 --> 00:01:36,850
A scatterplot is a two dimensional plot
similar to the line plots I've shown.

25
00:01:36,850 --> 00:01:40,695
The scatter function takes an x-axis
value as a first argument and

26
00:01:40,695 --> 00:01:43,530
y-axis value as the second.

27
00:01:43,530 --> 00:01:47,420
If the two arguments are the same, we
get a nice diagonal alignment of points.

28
00:01:49,220 --> 00:01:50,960
Let's do this now.

29
00:01:50,960 --> 00:01:54,155
I'll bring in numpy as we're
going to use it later and

30
00:01:54,155 --> 00:01:56,883
matplotlib is really
based on numpy arrays.

31
00:01:56,883 --> 00:02:00,060
I'll create a short array for
x and make y the same.

32
00:02:01,430 --> 00:02:03,600
Then create a new figure and scatterplot.

33
00:02:04,810 --> 00:02:07,565
You can see in this plot
a nice diagonal line and

34
00:02:07,565 --> 00:02:09,890
matplotlib has sized
our axises accordingly.

35
00:02:10,950 --> 00:02:14,480
Now, scatter doesn't
represent items as a series.

36
00:02:14,480 --> 00:02:18,390
Instead, we can pass it a list of colors
which correspond to given points.

37
00:02:19,990 --> 00:02:24,430
Let's use some list arithmetic to create a
new list just short of the number of data

38
00:02:24,430 --> 00:02:27,600
points we need and
set all of the values to green.

39
00:02:27,600 --> 00:02:29,501
Then we'll add a final value of red.

40
00:02:43,068 --> 00:02:44,357
Then we'll plot this, and

41
00:02:44,357 --> 00:02:48,130
we'll set the size of the data points to
100 to make it a little easier to see.

42
00:02:50,090 --> 00:02:52,340
The separation of data points into lists,

43
00:02:52,340 --> 00:02:57,230
which describes them as components is
a pretty common pattern in matplotlib.

44
00:02:57,230 --> 00:02:59,040
You have some set of items, but

45
00:02:59,040 --> 00:03:03,620
they're actually described as the same
slice across many different data sources.

46
00:03:04,720 --> 00:03:08,420
It's in one object-based language, but
you might expect that each data point is

47
00:03:08,420 --> 00:03:12,590
represented with its own instance,
which encapsulates all of its properties.

48
00:03:12,590 --> 00:03:17,320
For instance, it's called an x value and
a y value and a color and a size.

49
00:03:17,320 --> 00:03:19,148
That's not the case here.

50
00:03:19,148 --> 00:03:22,990
This is where it's useful to have some
knowledge of list comprehensions and

51
00:03:22,990 --> 00:03:26,540
lambdas as we talked about
in the first course.

52
00:03:26,540 --> 00:03:30,236
Also important is the zip function and
list unpacking.

53
00:03:30,236 --> 00:03:33,396
And because this is so
common in the Python data science world,

54
00:03:33,396 --> 00:03:36,270
I'm going to take a brief aside and
talk about that here.

55
00:03:38,290 --> 00:03:41,600
Recall that the zip method
takes a number of iterables and

56
00:03:41,600 --> 00:03:44,980
creates tuples out of them,
matching elements based on index.

57
00:03:46,260 --> 00:03:50,270
So if we have two lists of numbers,
zip will take the first from each and

58
00:03:50,270 --> 00:03:53,540
create a tuple, then the second from
each and create a tuple, and so on.

59
00:03:55,050 --> 00:03:59,770
Also remember that zip has lazy evaluation
because it's actually a generator

60
00:03:59,770 --> 00:04:03,150
in Python 3 which means we
need to use the list function

61
00:04:03,150 --> 00:04:05,460
if we want to see the results
of iterating over zip.

62
00:04:07,060 --> 00:04:08,480
Let's demonstrate.

63
00:04:08,480 --> 00:04:12,060
Here we'll create a new zip
generator with a zip function

64
00:04:12,060 --> 00:04:14,140
passing in two lists of numbers.

65
00:04:15,290 --> 00:04:19,932
When we convert this generator to a list,
we see there's a list of pairwise tuples.

66
00:04:21,735 --> 00:04:24,210
Storing point data as tuples is common and

67
00:04:24,210 --> 00:04:28,770
you should be familiar with being able
to convert data to and from this form.

68
00:04:29,790 --> 00:04:33,630
If we want to turn the data back into
two lists, one with the x component and

69
00:04:33,630 --> 00:04:37,520
one with the y component,
we can use parameter unpacking with zip.

70
00:04:38,660 --> 00:04:42,430
When you pass a list or an interval
more generally to a function and

71
00:04:42,430 --> 00:04:46,310
prepend it with an asterisk,
each item is taken out of the iterable and

72
00:04:46,310 --> 00:04:47,779
passed as a separate argument.

73
00:04:48,850 --> 00:04:53,040
So we can do that here, passing into
a new zip function five parameters,

74
00:04:53,040 --> 00:04:53,840
each of length two.

75
00:04:55,010 --> 00:05:00,220
Zip will then create a new two value list
which is identical to our original x and

76
00:05:00,220 --> 00:05:02,020
y values.

77
00:05:02,020 --> 00:05:03,490
If we want to get even fancier,

78
00:05:03,490 --> 00:05:07,620
we can unpack this result into
two variables directly, x and y.

79
00:05:09,650 --> 00:05:12,190
So that's a brief aside
on a variable tool.

80
00:05:12,190 --> 00:05:14,580
When it comes to manipulating and
cleaning data in the wild.

81
00:05:15,610 --> 00:05:17,090
Now, let's get back to plotting.

82
00:05:18,180 --> 00:05:23,920
Let's take these two lists and
plot them to a new figure using scatter.

83
00:05:23,920 --> 00:05:27,560
Instead of plotting them as one data
series, we'll slice the lists and

84
00:05:27,560 --> 00:05:28,820
plot them as two data series.

85
00:05:30,030 --> 00:05:34,620
You'll note that we can color each series
with a single value if we want to.

86
00:05:34,620 --> 00:05:36,660
We can also do things
like change the color or

87
00:05:36,660 --> 00:05:40,830
transparency of an entire series,
or individual data points as well.

88
00:05:42,750 --> 00:05:46,320
Finally, we have the ability to label
the data series, and I'll do that now.

89
00:05:47,320 --> 00:05:49,762
This will come in handy later
when building a legend.

90
00:05:52,168 --> 00:05:54,216
Now before we leave the scatter plot,

91
00:05:54,216 --> 00:05:57,035
let's talk a bit more about
the properties of axis.

92
00:05:58,250 --> 00:06:02,330
The axis generally have labels to them
to explain what they represent or

93
00:06:02,330 --> 00:06:03,460
the units that they describe.

94
00:06:04,540 --> 00:06:07,700
Charts tend to have titles as well,
so let's put this in place now.

95
00:06:09,200 --> 00:06:14,110
Since pyplot mirrors much of the axis API,
we can make calls directly on pyplot.

96
00:06:15,220 --> 00:06:19,332
Let's do this now, adding in an xlabel,
a ylabel, and then a title.

97
00:06:35,909 --> 00:06:37,380
And let's add a legend as well.

98
00:06:38,990 --> 00:06:42,700
You'll see that matplotlib places this
in the upper left hand corner and

99
00:06:42,700 --> 00:06:45,920
puts a little visual about
our data series there.

100
00:06:45,920 --> 00:06:48,630
In the docs for the legend, you'll see
that there are a number of different

101
00:06:48,630 --> 00:06:51,210
parameters and one of them is called lock.

102
00:06:51,210 --> 00:06:54,095
And a value of 4, we'll put it in
the lower right hand corner of the axis.

103
00:06:55,480 --> 00:06:57,957
We could also get rid of the frame and
add a title, and

104
00:06:57,957 --> 00:07:00,164
do any number of different
transformations.

105
00:07:02,631 --> 00:07:06,610
The legend itself is an artist,
which means it can contain children.

106
00:07:06,610 --> 00:07:07,910
Let's take advantage of this and

107
00:07:07,910 --> 00:07:12,050
write a little routine to recursively go
through the list of children in an artist.

108
00:07:13,480 --> 00:07:16,782
First, we'll import the artist
class from matplotlib.

109
00:07:16,782 --> 00:07:19,990
Then we'll make a recursive function
which takes in an artist and

110
00:07:19,990 --> 00:07:21,610
some depth parameter.

111
00:07:21,610 --> 00:07:26,131
Then checks if the object is an artist and
if so, prints out its string name.

112
00:07:33,974 --> 00:07:37,310
Then recurses and
increases the depth for pretty printing.

113
00:07:38,950 --> 00:07:42,240
Finally, we can call this on
the legend object itself.

114
00:07:44,200 --> 00:07:48,492
So you can see the legend artist is
just made up of a number of different

115
00:07:48,492 --> 00:07:52,944
offsetboxes for drawing,
as well as TextAreas and PathCollections.

116
00:07:58,367 --> 00:08:02,164
What I want you to take away from this is
that there is nothing magical about what

117
00:08:02,164 --> 00:08:03,840
matplotlib is doing.

118
00:08:03,840 --> 00:08:08,030
Calls to the scripting interface,
just create figures, subplots, and axis.

119
00:08:08,030 --> 00:08:10,478
Then load those axis up
with various artists,

120
00:08:10,478 --> 00:08:14,600
which the back-end renders to the screen
or some other medium like a file.

121
00:08:15,940 --> 00:08:20,570
While you'll spend 95% of your time at the
scripting layer, happily creating graphs

122
00:08:20,570 --> 00:08:24,600
and charts, it's important to understand
how the library works underneath for

123
00:08:24,600 --> 00:08:25,890
the other 5% of the time.

124
00:08:27,570 --> 00:08:31,570
And the time that you will use this is
when you really want to have control over

125
00:08:31,570 --> 00:08:34,110
and to create your own charting functions,
and

126
00:08:34,110 --> 00:08:36,700
you'll have a chance to do that
by the end of this course.

127
00:08:38,150 --> 00:08:40,740
In the next lecture,
we'll go back into line plots and

128
00:08:40,740 --> 00:08:42,650
create a few more then onto bar charts.