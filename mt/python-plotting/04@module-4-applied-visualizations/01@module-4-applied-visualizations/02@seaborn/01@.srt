1
00:00:08,923 --> 00:00:10,170
Hi, everyone.

2
00:00:10,170 --> 00:00:12,070
Today, we'll be looking at Seaborn,

3
00:00:12,070 --> 00:00:14,900
a Python visualization
library based on matplotlib.

4
00:00:16,880 --> 00:00:20,280
Seaborn is really just
a wraparound matplotlib.

5
00:00:20,280 --> 00:00:24,711
It adds styles to make default data
visualizations much more visually

6
00:00:24,711 --> 00:00:30,061
appealing and makes creation of specific
types of complicated plots much simpler.

7
00:00:32,548 --> 00:00:35,730
To get us started,
I've imported seaborn as sns.

8
00:00:37,350 --> 00:00:40,610
Now, let's set the seed for
the random number generator.

9
00:00:40,610 --> 00:00:41,910
Which lets us reproduce the data.

10
00:00:43,740 --> 00:00:49,076
Next, let's make a panda series
v1 that's 1000 numbers drawn

11
00:00:49,076 --> 00:00:55,242
from a normal distribution with a mean
of 0, and a standard deviation of 10.

12
00:00:55,242 --> 00:00:59,614
Let's also make a second pandas series,
v2, which is 2 times v1,

13
00:00:59,614 --> 00:01:04,579
plus 1,000 numbers drawn from a normal
distribution with a mean of 60 and

14
00:01:04,579 --> 00:01:06,449
standard deviation of 15.

15
00:01:09,847 --> 00:01:13,545
Now let's see what the histograms of these
two variables look like when we plot

16
00:01:13,545 --> 00:01:14,450
them side by side.

17
00:01:16,180 --> 00:01:20,781
We can set alpha equal to 0.7 so
the histograms don't cover one another up.

18
00:01:25,499 --> 00:01:27,125
For the bin parameter,

19
00:01:27,125 --> 00:01:32,000
instead of integer denoting the number
of bins we want we can also pass in

20
00:01:32,000 --> 00:01:37,630
a specific sequence using np.arange to
specify the specific bins we want to use.

21
00:01:39,460 --> 00:01:43,750
This is useful for the one when we want
to plot two histograms in the same figure

22
00:01:43,750 --> 00:01:46,770
to make sure the bin sizes
are equivalent for both histograms.

23
00:01:48,850 --> 00:01:49,939
We also add labels so

24
00:01:49,939 --> 00:01:53,665
we can see which histogram belongs
to which variable using a legend.

25
00:01:57,120 --> 00:02:01,966
Looking at the histograms we can quickly
see that v1 has a lower mean than v2,

26
00:02:01,966 --> 00:02:04,550
and that v2 has a larger spread than v1.

27
00:02:06,860 --> 00:02:09,450
Even though up to this point
we've only used matplotlib for

28
00:02:09,450 --> 00:02:13,420
plotting we see that even importing
Seaborn has changed the aesthetics of

29
00:02:13,420 --> 00:02:16,610
the plot to a different style
from the matplotlib default.

30
00:02:18,260 --> 00:02:21,100
Let's visualize these histograms again but
in a different way.

31
00:02:23,000 --> 00:02:25,960
First, let's pass in both of
the series v1 and v2 in a list.

32
00:02:27,350 --> 00:02:29,560
And set the histtype to barstacked.

33
00:02:31,140 --> 00:02:36,040
Setting normed to True will normalize the
histogram to form a probability density.

34
00:02:37,710 --> 00:02:42,690
Next, let's create a variable v3,
which is the combination of v1 and v2.

35
00:02:44,360 --> 00:02:50,219
We'll use v3 to plot a kernel density
estimate plot over the stacked histogram.

36
00:02:50,219 --> 00:02:55,046
The kernel density estimation plot
estimates the probability density

37
00:02:55,046 --> 00:02:57,143
function of the variable v3.

38
00:02:57,143 --> 00:03:00,117
Plotting it on top of
the stacked histograms of v1 and

39
00:03:00,117 --> 00:03:04,230
v2 allows us to see the relationship
between these two visualizations.

40
00:03:06,130 --> 00:03:11,960
Seaborn provides a convenient function for
these type of plots sns.distplot.

41
00:03:11,960 --> 00:03:13,160
Let's take a look at how it works.

42
00:03:14,860 --> 00:03:19,786
We can pass in the variable we want to
visualize along with keyword arguments for

43
00:03:19,786 --> 00:03:22,742
each of the individual
components of the plot.

44
00:03:22,742 --> 00:03:27,357
Let's set the histogram color to teal and
the KDE color to navy.

45
00:03:30,551 --> 00:03:34,339
Now let's look at an example of one of
the types of complex plots that Seborn

46
00:03:34,339 --> 00:03:37,180
provides a convenient interface for,
the joint plot.

47
00:03:39,012 --> 00:03:42,340
The jointplot creates a scatterplot
along the histograms for

48
00:03:42,340 --> 00:03:44,420
each individual variable on each axis.

49
00:03:45,580 --> 00:03:49,690
You've actually seen jointplots in module
two and created them manually yourself.

50
00:03:51,580 --> 00:03:55,410
To create a jointplot,
we just type sns.jointplot and

51
00:03:55,410 --> 00:03:57,660
pass in the two series, v1 and v2.

52
00:03:58,840 --> 00:04:04,102
Setting alpha to 0.4 will help with
visualizing overlapping points.

53
00:04:04,102 --> 00:04:07,860
The jointplot allows us to visualize
the distribution of the two variables

54
00:04:07,860 --> 00:04:09,150
individually.

55
00:04:09,150 --> 00:04:12,400
As well as relationships
between the variables.

56
00:04:12,400 --> 00:04:14,720
Using jointplot we can see that v1 and

57
00:04:14,720 --> 00:04:19,940
v2 appear to be normally distributed
variables that are positively correlated.

58
00:04:19,940 --> 00:04:24,520
Because Seaborn uses matplotlib we can
tweak the plots using Matplotlib's tools.

59
00:04:26,250 --> 00:04:30,830
Some of the plotting functions in
Seaborn return a matplotlib axis object.

60
00:04:30,830 --> 00:04:33,090
While others operate on
an entire figure and

61
00:04:33,090 --> 00:04:36,540
produce plots with several panels,
returning a Seaborn grid object.

62
00:04:37,760 --> 00:04:42,612
In both cases, matplotlib can be
used to further tweak the plots.

63
00:04:42,612 --> 00:04:47,600
For example, sns.jointplot
returns a Seaborn grid object.

64
00:04:49,040 --> 00:04:55,160
From this we can plot a map plot axis
subplot object using grid.x joint.

65
00:04:56,970 --> 00:05:03,165
Then, we can set the aspect ratio to
be equal, using set_aspect equal.

66
00:05:03,165 --> 00:05:07,435
Hexbin plots are the bivariate
counterpart to histograms.

67
00:05:07,435 --> 00:05:10,690
Hexbin plots show the number of
observations that fall within

68
00:05:10,690 --> 00:05:11,730
hexagonal bins.

69
00:05:12,990 --> 00:05:15,920
Sns joint plot includes the hex bin style

70
00:05:15,920 --> 00:05:18,780
we can use by passing in
hex to the kind parameter.

71
00:05:21,402 --> 00:05:26,166
The hexbin style of plot works well
with relatively large data sets.

72
00:05:26,166 --> 00:05:31,101
Another good option for visualizing
the distribution of data sets is kernel

73
00:05:31,101 --> 00:05:33,427
density estimations or KDE plots.

74
00:05:33,427 --> 00:05:37,722
You can think of two dimensional KDE plots
as the continuous version of the hexbin

75
00:05:37,722 --> 00:05:38,430
jointplot.

76
00:05:40,450 --> 00:05:43,220
First, let's tell Seaborn
to use a different

77
00:05:43,220 --> 00:05:46,309
style using sns.set_style('white').

78
00:05:47,420 --> 00:05:49,980
All of the following charts will
have the gray grid turned off.

79
00:05:51,710 --> 00:05:55,500
Now we'll create a joint plot just
like before, except this time,

80
00:05:55,500 --> 00:05:57,290
let's set the kind to kde.

81
00:05:59,360 --> 00:06:03,876
Finally, let's space to 0,
which will plot the marginal distributions

82
00:06:03,876 --> 00:06:06,539
directly on the border
of the scatter plot.

83
00:06:06,539 --> 00:06:10,698
We can see that Seaborn has some
built-in options for easy customization.

84
00:06:10,698 --> 00:06:14,144
And provides us with easy to create and
beautiful plots for

85
00:06:14,144 --> 00:06:16,759
exploring the distributions of your data.

86
00:06:16,759 --> 00:06:20,440
For the last part of this tutorial,
let's load in the iris dataset,

87
00:06:20,440 --> 00:06:23,940
to see how Seaborn handles
visualizations of categorical data.

88
00:06:26,651 --> 00:06:27,639
Similar to pandas,

89
00:06:27,639 --> 00:06:30,960
Seaborn has a built in function
that creates a scatterplot matrix.

90
00:06:32,090 --> 00:06:33,590
We pass in the iris data of frame.

91
00:06:34,690 --> 00:06:37,870
Tell it to map name to different
colors using the hue parameter.

92
00:06:39,140 --> 00:06:41,979
And tell it to use a kde
along the diagonals instead

93
00:06:41,979 --> 00:06:43,608
of the default histograms.

94
00:06:47,429 --> 00:06:51,692
Looking at the pair plot, it's clear
there are some clusters in the data set.

95
00:06:51,692 --> 00:06:54,986
It looks like peddle length and
peddle width are good options for

96
00:06:54,986 --> 00:06:59,200
separating the observations,
whereas width is not a strong separator.

97
00:07:00,790 --> 00:07:04,080
Using pair plot to look at your data
frame can be a very useful tool

98
00:07:04,080 --> 00:07:06,650
in exploratory data analysis.

99
00:07:06,650 --> 00:07:09,111
One final plot I'd like to show
you is called the violin plot.

100
00:07:10,260 --> 00:07:13,790
You can think of a violin plot as a more
informative version of a box plot.

101
00:07:15,160 --> 00:07:18,900
To demonstrate, let's plot a violin
plot next to a swarm plot,

102
00:07:18,900 --> 00:07:21,490
which you can think of as a scatter
plot for categorical data.

103
00:07:23,140 --> 00:07:25,285
First let's create a new figure and
a subplot.

104
00:07:26,970 --> 00:07:30,510
Next, we'll create the swarmplot,
passing in Name and

105
00:07:30,510 --> 00:07:33,710
PetalLength, and the data,
which is the iris data frame.

106
00:07:35,280 --> 00:07:39,482
For the next subplot, we'll create
the violinplot, again passing in Name,

107
00:07:39,482 --> 00:07:41,530
PetalLength and the iris data frame.

108
00:07:44,990 --> 00:07:48,371
Looking at the swarmplot,
each species has its own column and

109
00:07:48,371 --> 00:07:50,850
each observation's petal length is shown.

110
00:07:50,850 --> 00:07:54,331
With more common values appearing
as the wide parts of the cluster,

111
00:07:54,331 --> 00:07:55,560
much like a histogram.

112
00:07:57,112 --> 00:08:01,630
The violinplot is like box plot with
a rotated kernel density estimation

113
00:08:01,630 --> 00:08:02,270
on each side.

114
00:08:04,227 --> 00:08:07,060
Violin plots convey more
information than box plots and

115
00:08:07,060 --> 00:08:10,650
are able to show particular
phenomena within the distribution

116
00:08:10,650 --> 00:08:14,770
that box plots are unable to
convey such as multi modality.

117
00:08:14,770 --> 00:08:18,740
Seaborn is a library that not only
adds new styles and visual aspects.

118
00:08:18,740 --> 00:08:23,500
But also introduces new functionality such
as joint plots, scatter matrix plots, and

119
00:08:23,500 --> 00:08:24,349
violin plots.

120
00:08:25,540 --> 00:08:29,040
Seaborn is being actively developed,
and is easy to install,

121
00:08:29,040 --> 00:08:32,810
which makes it an indispensible
part of a data scientist's toolkit.

122
00:08:32,810 --> 00:08:36,804
But keep in mind, this is functionality
built on top of matplotlib, and

123
00:08:36,804 --> 00:08:39,629
these are largely matplotlib
artists being used.

124
00:08:39,629 --> 00:08:43,183
So, if you have any ideas for
a new statistical visualization, or

125
00:08:43,183 --> 00:08:45,988
you've read about one in a publication or
journal.

126
00:08:45,988 --> 00:08:48,770
You should have the ability to create
your own visualization toolkits.

127
00:08:50,490 --> 00:08:53,830
That's it for Seaborn tutorial,
thanks for watching, happy plotting.